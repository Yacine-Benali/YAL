/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. mygrammar.jj */
/*@egen*/options {
    STATIC = false;
                 
                 
                                                  
                               
    FORCE_LA_CHECK = true;

    //DEBUG_PARSER = true;
}

PARSER_BEGIN(MyGrammar)
package main.jjtree;
import java.io.FileReader;
import main.*;


enum ExpType {
    Number,Boolean,FunctionCall,Variable
}

public class MyGrammar/*@bgen(jjtree)*/implements MyGrammarTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTMyGrammarState jjtree = new JJTMyGrammarState();

/*@egen*/



    public static void main(String args[]) {
        if (args.length != 1) {
            System.out.println("Usage: java MyGrammar <filename>");
            return;
        }

        String filename = args[0];
        try {
            FileReader fileReader = new FileReader(filename);
            MyGrammar parser = new MyGrammar(fileReader);
            parser.enable_tracing();

            SimpleNode rootNode = parser.Start();
             DotGenerator generator = new DotGenerator();
             generator.generateDot(rootNode);
             generator.getDotGraph();





            SemanticAnalysisVisitor visitor = new SemanticAnalysisVisitor();
            rootNode.jjtAccept(visitor, null); // Starts the visiting process*/





            System.out.println("File parsed successfully.");
        } catch (TokenMgrError e) {
            System.out.println("Lexical Error: \n" + e.getMessage());
        } catch (ParseException e) {
            System.out.println("Syntax Error: \n" + e.getMessage());
            System.out.println(e.currentToken.next.kind);
            //System.out.println(e.);
        } catch ( Throwable t) {
            System.out.println("other error:");
            t.printStackTrace();
        }
    }
}




PARSER_END(MyGrammar)

SKIP : {
    " " | "\t" | "\n" | "\r" | "' '"| "''"
}

TOKEN : {
    < #MINLETTER : ["a"-"z"]>
|   < #CAPLETTER : ["A"-"Z"] >
|   < #DIGIT : ["0"-"9"] >
// |   < #INT : (<DIGIT>)+ >
// |   < #REAL : <INT> "." <INT> >
|   < NUMBER : (<DIGIT>)+ |  (<DIGIT>)+ "." (<DIGIT>)+ >
/*|   < INT_KEYWORD : "int" >
|   < REAL_KEYWORD : "real" >*/
|   < NUMBER_KEYWORD : "number" >
|   < STRING_KEYWORD : "string" >
|   < BOOL_KEYWORD : "bool" >
|   < PROGRAM : "program" >
|   < FUNCTION : "function" >
|   < PROCEDURE : "procedure" >
|   < VAR : "var" >
|   < BEGIN : "begin" >
|   < END : "end" >
|   < WHILE : "while" >
|   < DO : "do" >
|   < IF : "if" >
|   < THEN : "then" >
|   < ELSE : "else" >
|   < TRUE : "true" >
|   < FALSE : "false" >
|   < NOT : "NOT" >
|   < OR : "OR" >
|   < AND : "AND" >
// identifier is last else it will also match the above strings
|   < IDENTIFIER :
        <MINLETTER> (<MINLETTER> | <CAPLETTER>| <DIGIT>)*
    >
|   < ASSIGN : ":=" >
|   < LPAREN : "(" >
|   < RPAREN : ")" >
|   < COMMA : "," >
|   <COLON : ":">
|   < SEMICOLON : ";" >
|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULTIPLY : "*" >
|   < DIVIDE : "/" >
|   < LESS : "<" >
|   < GREATER : ">" >
|   < LESSEQUAL : "<=" >
|   < GREATEREQUAL : ">=" >
|   < EQUAL : "==" >
|   < NOTEQUAL : "!=" >
/*
  Double Quotes: The string starts and ends with a double quote (\").

  Character Matching: Inside the string, you can have any character except a double quote or a backslash (~["\"","\\"]). This is to ensure that the parser does not prematurely end the string or misinterpret a backslash.

  Escape Sequences: If a backslash (\\) is encountered, it's followed by either a single character for standard escape sequences (like n, t, b, r, f, \\, \", \') or by up to three octal digits (["0"-"7"]).

  Repetition (*): The combination of characters and escape sequences can repeat any number of times.
  * */
|   < STRING :
        "\""
        (
          ~["\"","\\"] // Match any character except double quote or backslash
        |
          "\\"
          (
            ["n","t","b","r","f","\\","\"","'"] // Standard escape sequences
          |
            ["0"-"7"] ( ["0"-"7"] )? // Octal escape (up to 3 octal digits)
          )
        )*
        "\""
    >
}


// High-level structure
SimpleNode Start()        :
{/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
    try {
/*@egen*/
    programHeading() (functionDeclaration())* (procedureDeclaration())* block()/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void programHeading() :
{/*@bgen(jjtree) programHeading */
  ASTprogramHeading jjtn000 = new ASTprogramHeading(JJTPROGRAMHEADING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) programHeading */
    try {
/*@egen*/
    <PROGRAM> identifier()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Function-related rules
void functionDeclaration() :
{/*@bgen(jjtree) functionDeclaration */
  ASTfunctionDeclaration jjtn000 = new ASTfunctionDeclaration(JJTFUNCTIONDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) functionDeclaration */
    try {
/*@egen*/
    functionHeading() functionBody()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void functionHeading()                  :
{/*@bgen(jjtree) functionHeading */
 ASTfunctionHeading jjtn000 = new ASTfunctionHeading(JJTFUNCTIONHEADING);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token functionName,returnType;}
{/*@bgen(jjtree) functionHeading */
    try {
/*@egen*/
    <FUNCTION> functionName=identifier() [formalParameterList()] <COLON> returnType=typeIdentifier()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.functionName = functionName.image;
        jjtn000.returnType = returnType.image;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void functionBody() :
{/*@bgen(jjtree) functionBody */
  ASTfunctionBody jjtn000 = new ASTfunctionBody(JJTFUNCTIONBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) functionBody */
    try {
/*@egen*/
    block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void formalParameterList()                      :
{/*@bgen(jjtree) formalParameterList */
  ASTformalParameterList jjtn000 = new ASTformalParameterList(JJTFORMALPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) formalParameterList */
    try {
/*@egen*/
    <LPAREN> [formalParameterSection()] (<COMMA> formalParameterSection())* <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void formalParameterSection()                        :
{/*@bgen(jjtree) formalParameterSection */
 ASTformalParameterSection jjtn000 = new ASTformalParameterSection(JJTFORMALPARAMETERSECTION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token paramName, paramType;}
{/*@bgen(jjtree) formalParameterSection */
    try {
/*@egen*/
    paramName=identifier() <COLON> paramType=typeIdentifier()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
        jjtn000.paramType = paramType.image;
        jjtn000.paramName = paramName.image;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Procedure-related rules
void procedureDeclaration() :
{/*@bgen(jjtree) procedureDeclaration */
  ASTprocedureDeclaration jjtn000 = new ASTprocedureDeclaration(JJTPROCEDUREDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) procedureDeclaration */
    try {
/*@egen*/
    procedureHeading() procedureBody()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void procedureHeading() :
{/*@bgen(jjtree) procedureHeading */
 ASTprocedureHeading jjtn000 = new ASTprocedureHeading(JJTPROCEDUREHEADING);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token name;}
{/*@bgen(jjtree) procedureHeading */
    try {
/*@egen*/
    <PROCEDURE> name=identifier() [formalParameterList()]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.name = name.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void procedureBody() :
{/*@bgen(jjtree) procedureBody */
  ASTprocedureBody jjtn000 = new ASTprocedureBody(JJTPROCEDUREBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) procedureBody */
    try {
/*@egen*/
    block()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Block and statements
void block() :
{/*@bgen(jjtree) block */
  ASTblock jjtn000 = new ASTblock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) block */
    try {
/*@egen*/
    [variableDeclarationPart()] statementPart()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void variableDeclarationPart() :
{/*@bgen(jjtree) variableDeclarationPart */
  ASTvariableDeclarationPart jjtn000 = new ASTvariableDeclarationPart(JJTVARIABLEDECLARATIONPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) variableDeclarationPart */
    try {
/*@egen*/
    <VAR> variableDeclaration() <SEMICOLON> ( variableDeclaration() <SEMICOLON>)*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void variableDeclaration() :
{/*@bgen(jjtree) variableDeclaration */
 ASTvariableDeclaration jjtn000 = new ASTvariableDeclaration(JJTVARIABLEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token varName,varType; }
{/*@bgen(jjtree) variableDeclaration */
    try {
/*@egen*/
    varName=identifier() <COLON> varType=typeIdentifier()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.name= varName.image; jjtn000.type=varType.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statementPart() :
{/*@bgen(jjtree) statementPart */
  ASTstatementPart jjtn000 = new ASTstatementPart(JJTSTATEMENTPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statementPart */
    try {
/*@egen*/
    <BEGIN> [statementSequence()] <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statementSequence() :
{/*@bgen(jjtree) statementSequence */
  ASTstatementSequence jjtn000 = new ASTstatementSequence(JJTSTATEMENTSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statementSequence */
    try {
/*@egen*/
    statement() ( statement() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement() :
{/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
    try {
/*@egen*/
    simpleStatement() | structuredStatement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void simpleStatement() :
{/*@bgen(jjtree) simpleStatement */
  ASTsimpleStatement jjtn000 = new ASTsimpleStatement(JJTSIMPLESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) simpleStatement */
    try {
/*@egen*/
    /*
        parser cant tell the diff between assignment and procedureCall
        because they both start with Identifier
    */
    LOOKAHEAD(3) assignmentStatement() <SEMICOLON> | procedureCall() <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void assignmentStatement() : {/*@bgen(jjtree) assignmentStatement */
                              ASTassignmentStatement jjtn000 = new ASTassignmentStatement(JJTASSIGNMENTSTATEMENT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/String variableName; String expressionType="string"; }
{/*@bgen(jjtree) assignmentStatement */
   try {
/*@egen*/
   variableName=variableIdentifier() <ASSIGN>
    (
    expression()
    | <STRING>
    //| variableIdentifier()
    )/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/

   {jjtn000.variableName = variableName; jjtn000.expressionType = expressionType;}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void procedureCall() :{/*@bgen(jjtree) procedureCall */
                       ASTprocedureCall jjtn000 = new ASTprocedureCall(JJTPROCEDURECALL);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) procedureCall */
    try {
/*@egen*/
    id=identifier() actualParameterList()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {jjtn000.name = id.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void structuredStatement() :
{/*@bgen(jjtree) structuredStatement */
  ASTstructuredStatement jjtn000 = new ASTstructuredStatement(JJTSTRUCTUREDSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) structuredStatement */
    try {
/*@egen*/
    whileStatement()
    |
    ifStatement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void whileStatement() :
{/*@bgen(jjtree) whileStatement */
  ASTwhileStatement jjtn000 = new ASTwhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) whileStatement */
    try {
/*@egen*/
    <WHILE> boolExp() <DO> statementPart()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ifStatement() :
{/*@bgen(jjtree) ifStatement */
  ASTifStatement jjtn000 = new ASTifStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifStatement */
    try {
/*@egen*/
    <IF> boolExp() <THEN> statementPart() [ <ELSE> statementPart() ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
// Helper methods for identifiers and types
void identifierList() :
{/*@bgen(jjtree) identifierList */
  ASTidentifierList jjtn000 = new ASTidentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) identifierList */
    try {
/*@egen*/
    identifier() (<COMMA> identifier())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

Token typeIdentifier() :
{/*@bgen(jjtree) typeIdentifier */
  ASTtypeIdentifier jjtn000 = new ASTtypeIdentifier(JJTTYPEIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) typeIdentifier */
   try {
/*@egen*/
  // (t = <INT_KEYWORD> { return t; }) |
   (t = <NUMBER_KEYWORD>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return t; }) |
   (t = <STRING_KEYWORD>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return t; }) |
   (t = <BOOL_KEYWORD>/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ { return t; } )/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/

}

Token identifier() :
{/*@bgen(jjtree) identifier */
 ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t ;}
{/*@bgen(jjtree) identifier */
    try {
/*@egen*/
    t = <IDENTIFIER>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { return t;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String variableIdentifier() :
{/*@bgen(jjtree) variableIdentifier */
 ASTvariableIdentifier jjtn000 = new ASTvariableIdentifier(JJTVARIABLEIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) variableIdentifier */
    try {
/*@egen*/
    t=identifier()/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {return t.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Expression
void expression() : {/*@bgen(jjtree) expression */
                     ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) expression */
    try {
/*@egen*/
    /*
        parser cant tell the diff between arthExp and boolexp
        becaus they both start with "-" <NUMBER>
        arthExp = -5 + 2
        boolexp = -5 > 3
    */
    LOOKAHEAD(3)
    type=arthExp()
    |
    boolExp()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}
// Arithmetic Expressions
ExpType arthExp() :
{/*@bgen(jjtree) arthExp */
 ASTarthExp jjtn000 = new ASTarthExp(JJTARTHEXP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) arthExp */
    try {
/*@egen*/

    type=arthTerm() arthExpPrime(type)/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/{ return type; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arthExpPrime(ExpType inheritedType) :
{/*@bgen(jjtree) arthExpPrime */
 ASTarthExpPrime jjtn000 = new ASTarthExpPrime(JJTARTHEXPPRIME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) arthExpPrime */
    try {
/*@egen*/
    <PLUS> type=arthTerm() arthExpPrime(type)/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ {/* checkType(inheritedType, type);*/ }
    |
    <MINUS> type = arthTerm() arthExpPrime(type)/*@bgen(jjtree)*/
                                                 {
                                                   jjtree.closeNodeScope(jjtn000, true);
                                                   jjtc000 = false;
                                                 }
/*@egen*/ { /*checkType(inheritedType, type);*/ }
    |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ExpType arthTerm() :
{/*@bgen(jjtree) arthTerm */
 ASTarthTerm jjtn000 = new ASTarthTerm(JJTARTHTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) arthTerm */
    try {
/*@egen*/
    type = arthFactor() arthTermPrime(type)/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/ { return type; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void arthTermPrime(ExpType inheritedType) :
{/*@bgen(jjtree) arthTermPrime */
 ASTarthTermPrime jjtn000 = new ASTarthTermPrime(JJTARTHTERMPRIME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) arthTermPrime */
    try {
/*@egen*/
    <MULTIPLY> type = arthFactor() arthTermPrime(type)/*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn000, true);
                                                         jjtc000 = false;
                                                       }
/*@egen*/ { /*checkType(inheritedType, type);*/ }
    |
    <DIVIDE> type = arthFactor() arthTermPrime(type)/*@bgen(jjtree)*/
                                                     {
                                                       jjtree.closeNodeScope(jjtn000, true);
                                                       jjtc000 = false;
                                                     }
/*@egen*/ { /*checkType(inheritedType, type);*/ }
    |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


ExpType arthFactor() :
{/*@bgen(jjtree) arthFactor */
 ASTarthFactor jjtn000 = new ASTarthFactor(JJTARTHFACTOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) arthFactor */
    try {
/*@egen*/
    <MINUS> type=numValue()/*@bgen(jjtree)*/
                            {
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                            }
/*@egen*/ { return type; }
    |
    type = numValue()/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ { return type; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
ExpType numValue() :
{/*@bgen(jjtree) numValue */
 ASTnumValue jjtn000 = new ASTnumValue(JJTNUMVALUE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) numValue */
    try {
/*@egen*/
    LOOKAHEAD(3) functionCall()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ { return ExpType.FunctionCall; }
    |
    variableIdentifier()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ { return ExpType.Variable; }
    |
    <LPAREN> type = arthExp() <RPAREN>/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/ { return type; }
    |
    number()/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { return ExpType.Number; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/


}

String number() : {/*@bgen(jjtree) number */
                   ASTnumber jjtn000 = new ASTnumber(JJTNUMBER);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/String type;}
{/*@bgen(jjtree) number */
    try {
/*@egen*/
    // <INT> {type = "int";}| <REAL> {type="real";}
    <NUMBER> {type="number";}/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return type;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
// Boolean Expressions
ExpType boolExp() :
{/*@bgen(jjtree) boolExp */
 ASTboolExp jjtn000 = new ASTboolExp(JJTBOOLEXP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolExp */
    try {
/*@egen*/
    type=boolTerm() boolExpPrime(type)/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/{ return type; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void boolExpPrime(ExpType inheritedType) :
{/*@bgen(jjtree) boolExpPrime */
 ASTboolExpPrime jjtn000 = new ASTboolExpPrime(JJTBOOLEXPPRIME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolExpPrime */
    try {
/*@egen*/
    <OR> type=boolTerm() boolExpPrime(type)
    |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ExpType boolTerm() :
{/*@bgen(jjtree) boolTerm */
 ASTboolTerm jjtn000 = new ASTboolTerm(JJTBOOLTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolTerm */
    try {
/*@egen*/
    type = boolFactor() boolTermPrime(type)/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/ { return type; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void boolTermPrime(ExpType inheritedType) :
{/*@bgen(jjtree) boolTermPrime */
 ASTboolTermPrime jjtn000 = new ASTboolTermPrime(JJTBOOLTERMPRIME);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolTermPrime */
    try {
/*@egen*/
    <AND> type=boolFactor() boolTermPrime(type)
    |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ExpType boolFactor() :
{/*@bgen(jjtree) boolFactor */
 ASTboolFactor jjtn000 = new ASTboolFactor(JJTBOOLFACTOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolFactor */
    try {
/*@egen*/
    <NOT> type=boolVal()
    |
    type=boolVal()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return type;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

ExpType boolVal() :
{/*@bgen(jjtree) boolVal */
 ASTboolVal jjtn000 = new ASTboolVal(JJTBOOLVAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ExpType type;}
{/*@bgen(jjtree) boolVal */
    try {
/*@egen*/
    /*
    comp and (boolexp)
    common prefix is: "(" "-"
    */
    LOOKAHEAD(3) type=comp()/*@bgen(jjtree)*/
                             {
                               jjtree.closeNodeScope(jjtn000, true);
                               jjtc000 = false;
                             }
/*@egen*/ {return type;}
    |
    <LPAREN> type=boolExp() <RPAREN>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ {return type;}
    |
    /*
        cant tell between  functioncall & comp()
        because both start with Identifier (
        if comp() leads to an
        arithmetic expression that starts with a function call
    */
    LOOKAHEAD(2) functionCall()/*@bgen(jjtree)*/
                                {
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                }
/*@egen*/ {return ExpType.FunctionCall;}
    |
    variableIdentifier()/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {return ExpType.Variable;}
    |
    <TRUE>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {return ExpType.Boolean;}
    |
    <FALSE>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {return ExpType.Boolean;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}

ExpType comp() :
{/*@bgen(jjtree) comp */
  ASTcomp jjtn000 = new ASTcomp(JJTCOMP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comp */
    try {
/*@egen*/
    arthExp() compOp() arthExp()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return ExpType.Boolean;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void compOp() :
{/*@bgen(jjtree) compOp */
  ASTcompOp jjtn000 = new ASTcompOp(JJTCOMPOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) compOp */
    try {
/*@egen*/
    <LESS>
    |
    <GREATER>
    |
    <LESSEQUAL>
    |
    <GREATEREQUAL>
    |
    <EQUAL>
    |
    <NOTEQUAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

// Function Calls
ExpType functionCall()               :
{/*@bgen(jjtree) functionCall */
 ASTfunctionCall jjtn000 = new ASTfunctionCall(JJTFUNCTIONCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token id;}
{/*@bgen(jjtree) functionCall */
    try {
/*@egen*/
    id=identifier() actualParameterList()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {jjtn000.functionName = id.image;
    return ExpType.FunctionCall;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void actualParameterList() :
{/*@bgen(jjtree) actualParameterList */
  ASTactualParameterList jjtn000 = new ASTactualParameterList(JJTACTUALPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) actualParameterList */
    try {
/*@egen*/
    <LPAREN> [actualParameter() (<COMMA> actualParameter())* ] <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void actualParameter() : {/*@bgen(jjtree) actualParameter */
                          ASTactualParameter jjtn000 = new ASTactualParameter(JJTACTUALPARAMETER);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/String type;Boolean isIdentifier = false;}
{/*@bgen(jjtree) actualParameter */
    try {
/*@egen*/
    /*
        LOOKAHEAD(3)
        cant tell between  expression & functioncall()
        because both start with Identifier (
        expression leads to an
        arithmetic expression that starts with a function call
    */

    /*
            LOOKAHEAD(2)
            parser cant tell the diff between varid and functid
            becaus they both start with Identifier
    */
    // REMOVED LOOKAHEAD(3) type=expression() {jjtThis.type =type;} |
    LOOKAHEAD(2) type=variableIdentifier()/*@bgen(jjtree)*/
                                           {
                                             jjtree.closeNodeScope(jjtn000, true);
                                             jjtc000 = false;
                                           }
/*@egen*/ {jjtn000.isIdentifier= true;jjtn000.type =type;} |

    <STRING>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {type = "string"; jjtn000.type =type; jjtn000.isIdentifier=false;} |
    <TRUE>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {type = "bool"; jjtn000.type =type;jjtn000.isIdentifier=false;} |
    <FALSE>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/ {type = "bool"; jjtn000.type =type;jjtn000.isIdentifier=false;} |
    type=number()/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.type =type;jjtn000.isIdentifier=false;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/

}
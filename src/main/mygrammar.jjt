options {
    STATIC = false;
    VISITOR=true;
    MULTI = true;
    JJTREE_OUTPUT_DIRECTORY = "./src/main/jjtree";
    NODE_PACKAGE="main.jjtree";

    //DEBUG_PARSER = true;
}

PARSER_BEGIN(MyGrammar)
package main.jjtree;
import java.io.FileReader;
import main.*;


enum ExpType {
    Number,Boolean,FunctionCall,Variable
}

public class MyGrammar {



    public static void main(String args[]) {
        if (args.length != 1) {
            System.out.println("Usage: java MyGrammar <filename>");
            return;
        }

        String filename = args[0];
        try {
            FileReader fileReader = new FileReader(filename);
            MyGrammar parser = new MyGrammar(fileReader);
            parser.enable_tracing();

            SimpleNode rootNode = parser.Start();
             DotGenerator generator = new DotGenerator();
             generator.generateDot(rootNode);
             generator.getDotGraph();





            SemanticAnalysisVisitor visitor = new SemanticAnalysisVisitor();
            rootNode.jjtAccept(visitor, null); // Starts the visiting process*/





            System.out.println("File parsed successfully.");
        } catch (TokenMgrError e) {
            System.out.println("Lexical Error: \n" + e.getMessage());
        } catch (ParseException e) {
            System.out.println("Syntax Error: \n" + e.getMessage());
            System.out.println(e.currentToken.next.kind);
            //System.out.println(e.);
        } catch ( Throwable t) {
            System.out.println("other error:");
            t.printStackTrace();
        }
    }
}




PARSER_END(MyGrammar)

SKIP : {
    " " | "\t" | "\n" | "\r" | "' '"| "''"
}

TOKEN : {
    < #MINLETTER : ["a"-"z"]>
|   < #CAPLETTER : ["A"-"Z"] >
|   < #DIGIT : ["0"-"9"] >
// |   < #INT : (<DIGIT>)+ >
// |   < #REAL : <INT> "." <INT> >
|   < NUMBER : (<DIGIT>)+ |  (<DIGIT>)+ "." (<DIGIT>)+ >
/*|   < INT_KEYWORD : "int" >
|   < REAL_KEYWORD : "real" >*/
|   < NUMBER_KEYWORD : "number" >
|   < STRING_KEYWORD : "string" >
|   < BOOL_KEYWORD : "bool" >
|   < PROGRAM : "program" >
|   < FUNCTION : "function" >
|   < PROCEDURE : "procedure" >
|   < VAR : "var" >
|   < BEGIN : "begin" >
|   < END : "end" >
|   < WHILE : "while" >
|   < DO : "do" >
|   < IF : "if" >
|   < THEN : "then" >
|   < ELSE : "else" >
|   < TRUE : "true" >
|   < FALSE : "false" >
|   < NOT : "NOT" >
|   < OR : "OR" >
|   < AND : "AND" >
// identifier is last else it will also match the above strings
|   < IDENTIFIER :
        <MINLETTER> (<MINLETTER> | <CAPLETTER>| <DIGIT>)*
    >
|   < ASSIGN : ":=" >
|   < LPAREN : "(" >
|   < RPAREN : ")" >
|   < COMMA : "," >
|   <COLON : ":">
|   < SEMICOLON : ";" >
|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULTIPLY : "*" >
|   < DIVIDE : "/" >
|   < LESS : "<" >
|   < GREATER : ">" >
|   < LESSEQUAL : "<=" >
|   < GREATEREQUAL : ">=" >
|   < EQUAL : "==" >
|   < NOTEQUAL : "!=" >
/*
  Double Quotes: The string starts and ends with a double quote (\").

  Character Matching: Inside the string, you can have any character except a double quote or a backslash (~["\"","\\"]). This is to ensure that the parser does not prematurely end the string or misinterpret a backslash.

  Escape Sequences: If a backslash (\\) is encountered, it's followed by either a single character for standard escape sequences (like n, t, b, r, f, \\, \", \') or by up to three octal digits (["0"-"7"]).

  Repetition (*): The combination of characters and escape sequences can repeat any number of times.
  * */
|   < STRING :
        "\""
        (
          ~["\"","\\"] // Match any character except double quote or backslash
        |
          "\\"
          (
            ["n","t","b","r","f","\\","\"","'"] // Standard escape sequences
          |
            ["0"-"7"] ( ["0"-"7"] )? // Octal escape (up to 3 octal digits)
          )
        )*
        "\""
    >
}


// High-level structure
SimpleNode Start() #Start :
{}
{
    programHeading() (functionDeclaration())* (procedureDeclaration())* block()
     { return jjtThis; }
}

void programHeading() :
{}
{
    <PROGRAM> identifier()
}

// Function-related rules
void functionDeclaration() :
{}
{
    functionHeading() functionBody()
}

void functionHeading() #functionHeading :
{Token functionName,returnType;}
{
    <FUNCTION> functionName=identifier() [formalParameterList()] <COLON> returnType=typeIdentifier()
    {
        jjtThis.functionName = functionName.image;
        jjtThis.returnType = returnType.image;
    }
}

void functionBody() :
{}
{
    block()
}

void formalParameterList() #formalParameterList :
{}
{
    <LPAREN> [formalParameterSection()] (<COMMA> formalParameterSection())* <RPAREN>
}

void formalParameterSection() #formalParameterSection:
{Token paramName, paramType;}
{
    paramName=identifier() <COLON> paramType=typeIdentifier()

    {
        jjtThis.paramType = paramType.image;
        jjtThis.paramName = paramName.image;
    }
}

// Procedure-related rules
void procedureDeclaration() :
{}
{
    procedureHeading() procedureBody()
}

void procedureHeading() :
{Token name;}
{
    <PROCEDURE> name=identifier() [formalParameterList()]
    {jjtThis.name = name.image;}
}

void procedureBody() :
{}
{
    block()
}

// Block and statements
void block() :
{}
{
    [variableDeclarationPart()] statementPart()
}

void variableDeclarationPart() :
{}
{
    <VAR> variableDeclaration() <SEMICOLON> ( variableDeclaration() <SEMICOLON>)*
}

void variableDeclaration() :
{Token varName,varType; }
{
    varName=identifier() <COLON> varType=typeIdentifier()
    {jjtThis.name= varName.image; jjtThis.type=varType.image;}
}

void statementPart() :
{}
{
    <BEGIN> [statementSequence()] <END>
}

void statementSequence() :
{}
{
    statement() ( statement() )*
}

void statement() :
{}
{
    simpleStatement() | structuredStatement()
}

void simpleStatement() :
{}
{
    /*
        parser cant tell the diff between assignment and procedureCall
        because they both start with Identifier
    */
    LOOKAHEAD(2) assignmentStatement() <SEMICOLON> | procedureCall() <SEMICOLON>
}

void assignmentStatement() : {String variableName; String expressionType="string"; }
{
   variableName=variableIdentifier() <ASSIGN>
    (
    expression()
    | <STRING>
    //| variableIdentifier()
    )

   {jjtThis.variableName = variableName; jjtThis.expressionType = expressionType;}
}

void procedureCall() :{Token id;}
{
    id=identifier() actualParameterList()
   {jjtThis.name = id.image;}
}

void structuredStatement() :
{}
{
    whileStatement()
    |
    ifStatement()
}

void whileStatement() :
{}
{
    <WHILE> boolExp() <DO> statementPart()
}

void ifStatement() :
{}
{
    <IF> boolExp() <THEN> statementPart() [ <ELSE> statementPart() ]
}
// Helper methods for identifiers and types
void identifierList() :
{}
{
    identifier() (<COMMA> identifier())*
}

Token typeIdentifier() :
{ Token t = null; }
{
  // (t = <INT_KEYWORD> { return t; }) |
   (t = <NUMBER_KEYWORD> { return t; }) |
   (t = <STRING_KEYWORD> { return t; }) |
   (t = <BOOL_KEYWORD> { return t; } )

}

Token identifier() :
{Token t ;}
{
    t = <IDENTIFIER> { return t;}
}

String variableIdentifier() :
{Token t;}
{
    t=identifier() {return t.image;}
}

// Expression
void expression() : {ExpType type;}
{
    /*
        parser cant tell the diff between arthExp and boolexp
        becaus they both start with "-" <NUMBER>
        arthExp = -5 + 2
        boolexp = -5 > 3
    */
    LOOKAHEAD(3)
    type=arthExp()
    |
    boolExp()

}
// Arithmetic Expressions
ExpType arthExp() :
{ExpType type;}
{

    type=arthTerm() arthExpPrime(type){ return type; }
}

void arthExpPrime(ExpType inheritedType) :
{ExpType type;}
{
    <PLUS> type=arthTerm() arthExpPrime(type) {/* checkType(inheritedType, type);*/ }
    |
    <MINUS> type = arthTerm() arthExpPrime(type) { /*checkType(inheritedType, type);*/ }
    |
    {}
}

ExpType arthTerm() :
{ExpType type;}
{
    type = arthFactor() arthTermPrime(type) { return type; }
}
void arthTermPrime(ExpType inheritedType) :
{ExpType type;}
{
    <MULTIPLY> type = arthFactor() arthTermPrime(type) { /*checkType(inheritedType, type);*/ }
    |
    <DIVIDE> type = arthFactor() arthTermPrime(type) { /*checkType(inheritedType, type);*/ }
    |
    {}
}


ExpType arthFactor() :
{ExpType type;}
{
    <MINUS> type=numValue() { return type; }
    |
    type = numValue() { return type; }
}
ExpType numValue() :
{ExpType type;}
{
    LOOKAHEAD(3) functionCall() { return ExpType.FunctionCall; }
    |
    variableIdentifier() { return ExpType.Variable; }
    |
    <LPAREN> type = arthExp() <RPAREN> { return type; }
    |
    number() { return ExpType.Number; }


}

String number() : {String type;}
{
    // <INT> {type = "int";}| <REAL> {type="real";}
    <NUMBER> {type="number";}
    {return type;}
}
// Boolean Expressions
ExpType boolExp() :
{ExpType type;}
{
    type=boolTerm() boolExpPrime(type){ return type; }
}

void boolExpPrime(ExpType inheritedType) :
{ExpType type;}
{
    <OR> type=boolTerm() boolExpPrime(type)
    |
    {}
}

ExpType boolTerm() :
{ExpType type;}
{
    type = boolFactor() boolTermPrime(type) { return type; }
}

void boolTermPrime(ExpType inheritedType) :
{ExpType type;}
{
    <AND> type=boolFactor() boolTermPrime(type)
    |
    {}
}

ExpType boolFactor() :
{ExpType type;}
{
    <NOT> type=boolVal()
    |
    type=boolVal()
    {return type;}
}

ExpType boolVal() :
{ExpType type;}
{
    /*
    comp and (boolexp)
    common prefix is: "(" "-"
    */
    LOOKAHEAD(3) type=comp() {return type;}
    |
    <LPAREN> type=boolExp() <RPAREN> {return type;}
    |
    /*
        cant tell between  functioncall & comp()
        because both start with Identifier (
        if comp() leads to an
        arithmetic expression that starts with a function call
    */
    LOOKAHEAD(2) functionCall() {return ExpType.FunctionCall;}
    |
    variableIdentifier() {return ExpType.Variable;}
    |
    <TRUE> {return ExpType.Boolean;}
    |
    <FALSE> {return ExpType.Boolean;}

}

ExpType comp() :
{}
{
    arthExp() compOp() arthExp()
    {return ExpType.Boolean;}
}

void compOp() :
{}
{
    <LESS>
    |
    <GREATER>
    |
    <LESSEQUAL>
    |
    <GREATEREQUAL>
    |
    <EQUAL>
    |
    <NOTEQUAL>
}

// Function Calls
ExpType functionCall() #functionCall :
{Token id;}
{
    id=identifier() actualParameterList()
   {jjtThis.functionName = id.image;
    return ExpType.FunctionCall;
    }
}

void actualParameterList() :
{}
{
    <LPAREN> [actualParameter() (<COMMA> actualParameter())* ] <RPAREN>
}

void actualParameter() : {String type;Boolean isIdentifier = false;}
{
    /*
        LOOKAHEAD(3)
        cant tell between  expression & functioncall()
        because both start with Identifier (
        expression leads to an
        arithmetic expression that starts with a function call
    */

    /*
            LOOKAHEAD(2)
            parser cant tell the diff between varid and functid
            becaus they both start with Identifier
    */
    // REMOVED LOOKAHEAD(3) type=expression() {jjtThis.type =type;} |
    LOOKAHEAD(2) type=variableIdentifier() {jjtThis.isIdentifier= true;jjtThis.type =type;} |

    <STRING> {type = "string"; jjtThis.type =type; jjtThis.isIdentifier=false;} |
    <TRUE> {type = "bool"; jjtThis.type =type;jjtThis.isIdentifier=false;} |
    <FALSE> {type = "bool"; jjtThis.type =type;jjtThis.isIdentifier=false;} |
    type=number() {jjtThis.type =type;jjtThis.isIdentifier=false;}

}


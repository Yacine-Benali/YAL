options {
    STATIC = false;
    VISITOR=true;
    MULTI = true;
    JJTREE_OUTPUT_DIRECTORY = "./src/main/jjtree";
    NODE_PACKAGE="main.jjtree";

    //DEBUG_PARSER = true;
}

PARSER_BEGIN(MyGrammar)
package main.jjtree;
import java.io.FileReader;
import main.*;


enum ExpType {
    Number,Boolean,FunctionCall,Variable
}

public class MyGrammar {



    public static void main(String args[]) {
        if (args.length != 1) {
            System.out.println("Usage: java MyGrammar <filename>");
            return;
        }

        String filename = args[0];
        try {
            FileReader fileReader = new FileReader(filename);
            MyGrammar parser = new MyGrammar(fileReader);
            parser.enable_tracing();

            SimpleNode rootNode = parser.Start();
             DotGenerator generator = new DotGenerator();
             generator.generateDot(rootNode);
             generator.getDotGraph();





            SemanticAnalysisVisitor visitor = new SemanticAnalysisVisitor();
            rootNode.jjtAccept(visitor, null); // Starts the visiting process*/





            System.out.println("File parsed successfully.");
        } catch (TokenMgrError e) {
            System.out.println("Lexical Error: \n" + e.getMessage());
        } catch (ParseException e) {
            System.out.println("Syntax Error: \n" + e.getMessage());
            System.out.println(e.currentToken.next.kind);
            //System.out.println(e.);
        } catch ( Throwable t) {
            System.out.println("other error:");
            t.printStackTrace();
        }
    }
}






PARSER_END(MyGrammar)

SKIP : {
    " " | "\t" | "\n" | "\r" | "' '"| "''"
}

TOKEN : {
    < #MINLETTER : ["a"-"z"]>
|   < #CAPLETTER : ["A"-"Z"] >
|   < #DIGIT : ["0"-"9"] >
// |   < #INT : (<DIGIT>)+ >
// |   < #REAL : <INT> "." <INT> >
|   < NUMBER : (<DIGIT>)+ |  (<DIGIT>)+ "." (<DIGIT>)+ >
/*|   < INT_KEYWORD : "int" >
|   < REAL_KEYWORD : "real" >*/
|   < NUMBER_KEYWORD : "number" >
|   < STRING_KEYWORD : "string" >
|   < BOOL_KEYWORD : "bool" >
|   < PROGRAM : "program" >
|   < FUNCTION : "function" >
|   < PROCEDURE : "procedure" >
|   < VAR : "var" >
|   < BEGIN : "begin" >
|   < END : "end" >
|   < WHILE : "while" >
|   < DO : "do" >
|   < IF : "if" >
|   < THEN : "then" >
|   < ELSE : "else" >
|   < TRUE : "true" >
|   < FALSE : "false" >
|   < NOT : "!" >
|   < OR : "||" >
|   < AND : "&&" >
// identifier is last else it will also match the above strings
|   < IDENTIFIER :
        <MINLETTER> (<MINLETTER> | <CAPLETTER>| <DIGIT>)*
    >
|   < ASSIGN : ":=" >
|   < LPAREN : "(" >
|   < RPAREN : ")" >
|   < COMMA : "," >
|   <COLON : ":">
|   < SEMICOLON : ";" >
|   < PLUS : "+" >
|   < MINUS : "-" >
|   < MULTIPLY : "*" >
|   < DIVIDE : "/" >
|   < LESS : "<" >
|   < GREATER : ">" >
|   < LESSEQUAL : "<=" >
|   < GREATEREQUAL : ">=" >
|   < EQUAL : "==" >
|   < NOTEQUAL : "!=" >
/*
  Double Quotes: The string starts and ends with a double quote (\").

  Character Matching: Inside the string, you can have any character except a double quote or a backslash (~["\"","\\"]). This is to ensure that the parser does not prematurely end the string or misinterpret a backslash.

  Escape Sequences: If a backslash (\\) is encountered, it's followed by either a single character for standard escape sequences (like n, t, b, r, f, \\, \", \') or by up to three octal digits (["0"-"7"]).

  Repetition (*): The combination of characters and escape sequences can repeat any number of times.
  * */
|   < STRING :
        "\""
        (
          ~["\"","\\"] // Match any character except double quote or backslash
        |
          "\\"
          (
            ["n","t","b","r","f","\\","\"","'"] // Standard escape sequences
          |
            ["0"-"7"] ( ["0"-"7"] )? // Octal escape (up to 3 octal digits)
          )
        )*
        "\""
    >
}


// High-level structure
SimpleNode Start() #Start :
{}
{
    programHeading() (functionDeclaration())* (procedureDeclaration())* block()
     { return jjtThis; }
}

void programHeading() :
{}
{
    <PROGRAM> identifier()
}

// Function-related rules
void functionDeclaration() :
{}
{
    functionHeading() functionBody()
}

void functionHeading() #functionHeading :
{Token functionName,returnType;}
{
    <FUNCTION> functionName=identifier() [formalParameterList()] <COLON> returnType=typeIdentifier()
    {
        jjtThis.functionName = functionName.image;
        jjtThis.returnType = returnType.image;
    }
}

void functionBody() :
{}
{
    block()
}

void formalParameterList() #formalParameterList :
{}
{
    <LPAREN> [formalParameterSection()] (<COMMA> formalParameterSection())* <RPAREN>
}

void formalParameterSection() #formalParameterSection:
{Token paramName, paramType;}
{
    paramName=identifier() <COLON> paramType=typeIdentifier()

    {
        jjtThis.paramType = paramType.image;
        jjtThis.paramName = paramName.image;
    }
}

// Procedure-related rules
void procedureDeclaration() :
{}
{
    procedureHeading() procedureBody()
}

void procedureHeading() :
{Token name;}
{
    <PROCEDURE> name=identifier() [formalParameterList()]
    {jjtThis.name = name.image;}
}

void procedureBody() :
{}
{
    block()
}

// Block and statements
void block() :
{}
{
    [variableDeclarationPart()] statementPart()
}

void variableDeclarationPart() :
{}
{
    <VAR> variableDeclaration() <SEMICOLON> ( variableDeclaration() <SEMICOLON>)*
}

void variableDeclaration() :
{Token varName,varType; }
{
    varName=identifier() <COLON> varType=typeIdentifier()
    {jjtThis.name= varName.image; jjtThis.type=varType.image;}
}

void statementPart() :
{}
{
    <BEGIN> [statementSequence()] <END>
}

void statementSequence() :
{}
{
    statement() ( statement() )*
}

void statement() :
{}
{
    simpleStatement() | structuredStatement()
}

void simpleStatement() :
{}
{
    /*
        parser cant tell the diff between assignment and procedureCall
        because they both start with Identifier
    */
    LOOKAHEAD(2) assignmentStatement() <SEMICOLON> | procedureCall() <SEMICOLON>
}

void assignmentStatement() : {String variableName; String expressionType="string"; }
{
   variableName=variableIdentifier() <ASSIGN>(LOOKAHEAD(2)
   functionCall()  // expressions covers variable id & string & number but no function calls
   | Expression())


   {jjtThis.variableName = variableName; jjtThis.expressionType = expressionType;}
}

void procedureCall() :{Token id;}
{
    id=identifier() actualParameterList()
   {jjtThis.name = id.image;}
}

void structuredStatement() :
{}
{
    whileStatement()
    |
    ifStatement()
}

void whileStatement() :
{}
{
    <WHILE> Expression() <DO> statementPart()
}

void ifStatement() :
{}
{
    <IF> Expression() <THEN> statementPart() [ <ELSE> statementPart() ]
}
// Helper methods for identifiers and types
void identifierList() :
{}
{
    identifier() (<COMMA> identifier())*
}

Token typeIdentifier() :
{ Token t = null; }
{
  // (t = <INT_KEYWORD> { return t; }) |
   (t = <NUMBER_KEYWORD> { return t; }) |
   (t = <STRING_KEYWORD> { return t; }) |
   (t = <BOOL_KEYWORD> { return t; } )

}

Token identifier() :
{Token t ;}
{
    t = <IDENTIFIER> { return t;}
}

String variableIdentifier() :
{Token t;}
{
    t=identifier() {return t.image;}
}



void Expression() :
{ Token t;}
{
    AndExpression() (t=<OR> AndExpression(){jjtThis.operator = t.image;})*


}

void AndExpression():
{Token t;}
{
  EqualityExpression() ( t=<AND> EqualityExpression(){jjtThis.operator = t.image;})*
}



void EqualityExpression() :
{Token t;}
{
  RelationalExpression() (( t=<EQUAL> |  t=<NOTEQUAL> ) RelationalExpression() {jjtThis.operator = t.image;})*

}

void RelationalExpression():
{Token t;}
{
  AdditiveExpression()
  (
    (
       t=<LESS>
    |  t=<GREATER>
    |  t=<LESSEQUAL>
    |  t=<GREATEREQUAL>
    )
    AdditiveExpression()
    {jjtThis.operator = t.image;}
  )*
}



void AdditiveExpression() :
{Token t;}
{
  MultiplicativeExpression() (( t=<PLUS> |  t=<MINUS>) MultiplicativeExpression(){jjtThis.operator = t.image;})*

}

void MultiplicativeExpression() :
{Token t;}
{
  UnaryExpression() (( t=<MULTIPLY> |  t=<DIVIDE> ) UnaryExpression(){jjtThis.operator = t.image;})*

}


void UnaryExpression() :
{Token t = null;}
{
  t=<NOT>  UnaryExpression()
  | t=<MINUS> UnaryExpression()
  | N()
  {
    if (t == null)
        jjtThis.isUnary = true;
    else
        jjtThis.operator = t.image;

  }

}

void N() :
{}
{
  LiteralExpression()
  |
  <LPAREN>  Expression() < RPAREN>
  |
  variableIdentifier()

}

void LiteralExpression() :
{Token e;}
{
    e=<NUMBER>   {jjtThis.setValue(e.image); }
    |
    e=<STRING> {jjtThis.setValue(e.image); }


}

// Function Calls
ExpType functionCall() #functionCall :
{Token id;}
{
    id=identifier() actualParameterList()
   {jjtThis.functionName = id.image;
    return ExpType.FunctionCall;
    }
}

void actualParameterList() :
{}
{
    <LPAREN> [actualParameter() (<COMMA> actualParameter())* ] <RPAREN>
}

void actualParameter() : {String type;Boolean isIdentifier = false;}
{
    /*
        LOOKAHEAD(3)
        cant tell between  expression & functioncall()
        because both start with Identifier (
        expression leads to an
        arithmetic expression that starts with a function call
    */

    /*
            LOOKAHEAD(2)
            parser cant tell the diff between varid and functid
            becaus they both start with Identifier
    */
    // REMOVED LOOKAHEAD(3) type=expression() {jjtThis.type =type;} |
    LOOKAHEAD(2) type=variableIdentifier() {jjtThis.isIdentifier= true;jjtThis.type =type;} |

    <STRING> {type = "string"; jjtThis.type =type; jjtThis.isIdentifier=false;} |
    <TRUE> {type = "bool"; jjtThis.type =type;jjtThis.isIdentifier=false;} |
    <FALSE> {type = "bool"; jjtThis.type =type;jjtThis.isIdentifier=false;} |
    <NUMBER> {type="number" ;jjtThis.type =type;jjtThis.isIdentifier=false;}


}

